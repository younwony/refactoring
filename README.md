# 리팩토링

가장 처음으로 기능 명세서 작성하기

---
## 1. Method 분리

 1. indent(들여쓰기가 2이상인 경우) 줄이기
	- 메소드가 한가지 일만 하도록 구현
 2. else 예약어를 쓰지않는다
	- return 문으로 바로 return 제거
 3. compose method 패턴적용
	- 추상화 레벨을 동등하게 맞춘다.
		- ex) toInts, sum, is Blank -> 각각 하는 일은 1가지로 1레벨에 해당하게

### 메소드의 이상적인 인자개수
 1. 이상적인 인자개수 0개 이다. 다음이 1,2
 2. 3개는 가능한 피하는 편
 3. 4개는 특별한 이유가 있어도 사용하면 안된다.
---	
## 2. Class 분리

 1. 모든 원시값(primitive type), 문자열을 포장한다
	- Positive(String)
		- this(Integer.valueof(String))
    - Positive(int)
 2. 일급 콜렉션을 쓴다
 	- Collection 하나만을 가지는(포함하는) 클래스를 만든다.
 3. 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
---
# 연습대상 좋은 프로그램
 - 게임과 같이 요구사항이 명확한 프로그램
 - 의존관계(모바일 UI, 웹 UI, DB, 외부 API와 같은 의존관계 ) 가 없이 연습대상
 - 약간은 복잡한 로직이 있는 프로그램
 
 ## 예 (UI Console)
- 로또
- 사다리타기
- 볼링 게임 점수판
- 체스 게임 - 지뢰 찾기 게임
---	
### 위의 단계를 거친후 -> 의존관계를 추가하여 하기
## 다음 단계
 - 컴파일 에러를 최소화하면서 리팩토링하기
 - 레거시 어플리케이션에 테스트 코드 추가해 리펙토링 하기
    - 이게 가장 어렵다. 그런데 여기에 테스트 해볼라 하니 계속 실패
 
--- 
# 최종 참조 -> 객체지향 생활체조 원칙

1. 한 메스드에 오직 한 단계의 들여쓰기만 한다.
2. else 예약어를 쓰지 않는다.
3. 모든 원시값과 문자열을 포함한다.
4. 한 줄에 점을 하나만 찍는다.
5. 줄여쓰지 않는다 (축약 금지)
6. 모든 엔티티를 작게 유지한다.
7. 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
8. 일급 콜렉션을 쓴다.
9. Getter/Setter/Property를 쓰지 않는다.

# 메소드 인자개수
1. 이상적인 인자개수 0개 이다. 다음이 1,2
2. 3개는 가능한 피하는 편
3. 4개는 특별한 이유가 있어도 사용하면 안된다.
